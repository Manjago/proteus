# Proteus: Архитектура системы

> Документ описывает архитектуру, ключевые решения и принципы проекта.
> Обновляется синхронно с кодом.

## 1. Обзор

**Proteus** — симуляция искусственной жизни, вдохновлённая системой [Tierra](https://en.wikipedia.org/wiki/Tierra_(computer_simulation)) Томаса Рэя (1991).

Организмы — это самовоспроизводящиеся программы, живущие в общей памяти ("супе"). Они конкурируют за ресурсы (память, CPU-время), мутируют при копировании и эволюционируют.

### Цели проекта

- Воспроизвести ключевые механизмы Tierra на современном стеке (Java 21+)
- Наблюдать спонтанное возникновение паразитов, гиперпаразитов и экосистем
- Экспериментировать с параметрами эволюции

### Отличия от оригинальной Tierra

| Аспект | Tierra (1991) | Proteus |
|--------|---------------|---------|
| Язык | C | Java 21+ |
| ISA | 32 инструкции | 16 инструкций (ISA v1.1) |
| Адресация | Template-based | Прямая + Template (SEARCH) |
| Константы | Только вычисляемые | MOVI (21-bit immediate) |

---

## 2. Архитектура компонентов

```
┌─────────────────────────────────────────────────────────────┐
│                        Scheduler                            │
│                   (главный цикл симуляции)                  │
├─────────────────────────────────────────────────────────────┤
│                              │                              │
│    ┌─────────────────┐       │       ┌─────────────────┐    │
│    │   VirtualCPU    │       │       │  SystemCall     │    │
│    │                 │       │       │  Handler        │    │
│    │ - execute()     │◄──────┼──────►│                 │    │
│    │ - mutations     │       │       │ - allocate()    │    │
│    │                 │       │       │ - spawn()       │    │
│    └────────┬────────┘       │       │ - copy()        │    │
│             │                │       └────────┬────────┘    │
│             ▼                │                │             │
│    ┌─────────────────┐       │                ▼             │
│    │    CpuState     │       │       ┌─────────────────┐    │
│    │                 │       │       │ MemoryManager   │    │
│    │ - registers[8]  │       │       │                 │    │
│    │ - IP            │       │       │ - allocate()    │    │
│    │ - age, errors   │       │       │ - free()        │    │
│    └─────────────────┘       │       └────────┬────────┘    │
│                              │                │             │
│    ┌─────────────────┐       │                ▼             │
│    │    Organism     │       │       ┌─────────────────┐    │
│    │                 │◄──────┼──────►│     Reaper      │    │
│    │ - id, addr      │       │       │                 │    │
│    │ - size, parent  │       │       │ - register()    │    │
│    │ - alive, state  │       │       │ - reap()        │    │
│    └─────────────────┘       │       └─────────────────┘    │
│                              │                              │
├──────────────────────────────┴──────────────────────────────┤
│                     AtomicIntegerArray                      │
│                        "Soup" (10K cells)                   │
└─────────────────────────────────────────────────────────────┘
```

### Ключевые классы

| Класс | Ответственность |
|-------|-----------------|
| `OpCode` | Enum инструкций + encoding/decoding |
| `CpuState` | Состояние процессора организма (регистры, IP, счётчики) |
| `VirtualCPU` | Исполнение инструкций, мутации при COPY |
| `SystemCallHandler` | Интерфейс для ALLOCATE, SPAWN, COPY |
| `Organism` | Организм: геном, состояние, lifecycle |
| `MemoryManager` | Интерфейс управления памятью (allocate/free) |
| `FreeListMemoryManager` | Реализация: Free List + First Fit |
| `Reaper` | Интерфейс жнеца (убийство + освобождение) |
| `AgeBasedReaper` | Реализация: убивает старейших |
| `Disassembler` | Преобразование машинного кода в мнемоники |
| `GenomeBuilder` | Fluent API для ручного создания геномов |
| `Adam` | Первый самовоспроизводящийся организм (13 инструкций) |

---

## 3. Набор инструкций (ISA v1.1)

Полная спецификация: [ISA_SPEC.md](ISA_SPEC.md)

### Краткая сводка

| Категория | Инструкции |
|-----------|------------|
| Базовые | `NOP`, `MOV`, `MOVI` |
| Арифметика | `ADD`, `SUB`, `INC`, `DEC` |
| Память | `LOAD`, `STORE` |
| Управление | `JMP`, `JMPZ`, `JMPN` |
| Системные | `COPY`, `ALLOCATE`, `SPAWN` |
| Продвинутые | `SEARCH` |

### Кодирование

**Стандартный формат (32 бита):**
```
[8 bits: OpCode | 3 bits: R1 | 3 bits: R2 | 3 bits: R3 | 3 bits: R4 | 12 bits: reserved]
```

**Формат MOVI:**
```
[8 bits: OpCode | 3 bits: R_dst | 21 bits: immediate]
```

---

## 4. Принципы и дизайн-решения

### 4.1. Мутации только при COPY ✅

**Решение:** Мутации происходят ТОЛЬКО при выполнении инструкции `COPY`.

**Почему:**
- Биологичнее — мутации в природе происходят при репликации ДНК
- Предсказуемее — легче отлаживать и понимать
- Эффективнее — не нужен фоновый процесс мутаций

**Альтернативы (отвергнуты):**
- Фоновые мутации (cosmic rays) — добавляют шум без пользы
- Мутации при чтении — нереалистично

```java
// VirtualCPU.java
case COPY -> {
    int value = memory.get(srcAddr);
    if (random.nextDouble() < mutationRate) {
        value = mutate(value);  // ← Единственное место мутаций!
    }
    memory.set(dstAddr, value);
}
```

### 4.2. Отсутствие защиты памяти ✅

**Решение:** Организмы могут читать и писать ЛЮБУЮ ячейку памяти.

**Почему это ФИЧА, а не баг:**
- Позволяет появление **паразитов** (используют чужой код)
- Позволяет **хищничество** (портят конкурентов)
- Создаёт **экологическое давление** и интересную динамику
- Так было в оригинальной Tierra

**Наблюдаемое поведение:**
```
Adam (addr=0) был перезаписан потомками, которые копировали
себя поверх его кода. Это привело к "смерти" Adam'а и 
формированию экологических ниш.
```

### 4.3. Round-Robin планировщик ✅

**Решение:** Каждый организм получает ровно 1 инструкцию за цикл.

**Почему:**
- Простота реализации
- Честное распределение CPU
- Предсказуемость (важно для отладки)

```java
for (int cycle = 0; cycle < maxCycles; cycle++) {
    for (Organism org : organisms) {
        if (org.alive) {
            cpu.execute(org.state, soup);
        }
    }
}
```

**Будущие улучшения:** Можно добавить приоритеты или energy-based scheduling.

### 4.4. Смерть по количеству ошибок ✅

**Решение:** Организм умирает после 100 ошибок выполнения.

**Типы ошибок:**
- `ERROR_IP_OUT_OF_BOUNDS` — IP за пределами памяти
- `ERROR_UNKNOWN_OPCODE` — неизвестная инструкция
- `ERROR_MEMORY_OUT_OF_BOUNDS` — чтение/запись за пределами

**Почему порог, а не мгновенная смерть:**
- Даёт шанс "оправиться" от случайной ошибки
- Мутанты с небольшими повреждениями выживают
- Создаёт градиент fitness'а

### 4.5. MOVI для эффективных констант ✅

**Решение:** Добавлена инструкция `MOVI R, imm21` для загрузки констант.

**Было (Adam v1, 32 инструкции):**
```asm
INC R4      ; R4 = 1
ADD R4, R4  ; R4 = 2
ADD R4, R4  ; R4 = 4
...         ; 6 инструкций для загрузки 32!
```

**Стало (Adam v2, 13 инструкций):**
```asm
MOVI R4, 13  ; 1 инструкция!
```

**Почему 21 бит:** Достаточно для адресации 2M ячеек памяти.

---

## 5. Adam — первый организм

Adam — минимальный самовоспроизводящийся организм. Это "предок", от которого эволюционируют все остальные.

### Геном (13 инструкций)

```asm
; Инициализация
0000: MOVI R4, 13       ; R4 = SIZE
0001: MOVI R5, 5        ; R5 = COPY_LOOP address

; Выделение памяти
0002: ALLOCATE R4, R3   ; R3 = адрес для потомка

; Подготовка копирования  
0003: MOV R1, R3        ; R1 = destination pointer
0004: MOV R2, R4        ; R2 = counter

; Цикл копирования (адрес 5)
0005: COPY [R0], [R1]   ; Копировать с мутацией!
0006: INC R0            ; source++
0007: INC R1            ; dest++
0008: DEC R2            ; counter--
0009: JMPN R2, [R5]     ; if counter != 0, goto 5

; Порождение потомка
000A: SPAWN R3, R4      ; Зарегистрировать потомка

; Сброс и повтор
000B: SUB R0, R0        ; R0 = 0
000C: JMP [R6]          ; goto 0 (R6 всегда = 0)
```

### Регистры

| Регистр | Назначение |
|---------|------------|
| R0 | Source pointer (начинается с 0) |
| R1 | Destination pointer |
| R2 | Copy counter |
| R3 | Адрес потомка (от ALLOCATE) |
| R4 | Размер генома (13) |
| R5 | Адрес цикла копирования (5) |
| R6 | Всегда 0 (для JMP на старт) |
| R7 | Не используется |

### Жизненный цикл

```
┌─────────────────────────────────────────────────────────┐
│  1. MOVI R4, 13; MOVI R5, 5  — загрузка констант        │
│                              ↓                          │
│  2. ALLOCATE R4, R3          — запрос памяти            │
│                              ↓                          │
│  3. MOV R1, R3; MOV R2, R4   — подготовка указателей    │
│                              ↓                          │
│  ┌──────────────────────────────────────────────┐       │
│  │  4. COPY [R0], [R1]       — копирование      │ ×13   │
│  │  5. INC R0; INC R1; DEC R2                   │       │
│  │  6. JMPN R2, [R5]         — цикл             │       │
│  └──────────────────────────────────────────────┘       │
│                              ↓                          │
│  7. SPAWN R3, R4             — рождение потомка         │
│                              ↓                          │
│  8. SUB R0, R0; JMP [R6]     — сброс и повтор          │
└─────────────────────────────────────────────────────────┘
```

---

## 6. Управление памятью

### 6.1. Обзор

Память ("суп") — это общий массив из 10,000 ячеек (32-bit int каждая). Организмы конкурируют за место в супе.

```
┌─────────────────────────────────────────────────────────────┐
│                        SOUP (10,000 cells)                  │
├───────┬───────┬───────┬────────┬───────┬───────┬───────────┤
│ Org#0 │ Org#1 │ FREE  │ Org#3  │ FREE  │ Org#5 │   FREE    │
│  13   │  13   │  26   │   13   │  13   │  13   │   ...     │
└───────┴───────┴───────┴────────┴───────┴───────┴───────────┘
```

### 6.2. MemoryManager

**Алгоритм: Free List + First Fit**

Free List хранит список свободных блоков, отсортированных по адресу:

```
FreeList: [(addr=26, size=26), (addr=52, size=13), (addr=78, size=9922)]
```

**Операции:**

| Метод | Сложность | Описание |
|-------|-----------|----------|
| `allocate(size)` | O(n) | First Fit — первый подходящий блок |
| `free(addr, size)` | O(n) | Добавить + слить соседние |
| `getFreeMemory()` | O(n) | Сумма всех свободных блоков |
| `getLargestFreeBlock()` | O(n) | Максимальный непрерывный блок |

**Allocate (First Fit):**
```
1. Пройти по Free List
2. Найти первый блок с size >= requested
3. Если блок больше — разделить:
   - Вернуть начало блока
   - Остаток оставить в Free List
4. Если блок точно равен — удалить из Free List
5. Если не найден — вернуть -1
```

**Free + Coalesce:**
```
1. Добавить блок (addr, size) в Free List
2. Найти соседей:
   - Левый: блок, где (prev.addr + prev.size == addr)
   - Правый: блок, где (addr + size == next.addr)
3. Слить с соседями в один блок
4. Удалить старые блоки, добавить объединённый
```

**Пример слияния:**
```
До:   [(10, 5), (20, 10), (40, 15)]
Free(15, 5):
      [(10, 5), (15, 5), (20, 10), (40, 15)]  — добавили
      [(10, 20), (40, 15)]                     — слили 10+5+5+10=20
```

### 6.3. Интеграция с организмами

При **рождении** (SPAWN):
```java
int addr = memoryManager.allocate(size);
if (addr == -1) {
    // Нет места — вызвать Reaper или отказать
}
```

При **смерти**:
```java
organism.alive = false;
memoryManager.free(organism.startAddr, organism.size);
```

### 6.4. Фрагментация

**Проблема:** После многих allocate/free образуются маленькие "дыры", в которые не помещаются новые организмы.

```
┌────┬──┬────┬──┬────┬──┬────┬──────────────────┐
│Org │5 │Org │5 │Org │5 │Org │      FREE        │
│ 13 │  │ 13 │  │ 13 │  │ 13 │       100        │
└────┴──┴────┴──┴────┴──┴────┴──────────────────┘
       ↑      ↑      ↑
    Дыры по 5 — бесполезны для организмов размером 13
```

**Метрика фрагментации:**
```
fragmentation = 1 - (largestFreeBlock / totalFreeMemory)
```
- 0.0 = вся свободная память непрерывна
- 0.9 = 90% свободной памяти в мелких дырах

### 6.5. Дефрагментация (Stage 3)

> 📋 **TODO: Планируется для Stage 3**

**Проблема:** При высокой фрагментации allocate() не может найти блок, даже если суммарно памяти достаточно.

**Алгоритм компактификации:**
```
1. Остановить выполнение
2. Для каждого живого организма (в порядке адресов):
   a. Скопировать геном в начало свободной области
   b. Обновить organism.startAddr
   c. Обновить organism.state.IP (если указывает на старую позицию)
3. Обновить Free List (одна большая дыра в конце)
4. Продолжить выполнение
```

**Сложности:**
- IP может указывать на середину генома — нужно корректно сдвинуть
- R6 у Adam'а = 0 (начало генома) — после сдвига будет неверен
- Организмы могут ссылаться на чужие адреса (паразиты)

**Возможное решение:** Относительная адресация вместо абсолютной, или просто убивать организмы при дефрагментации (естественный отбор!).

---

## 7. Reaper (Жнец)

### 7.1. Назначение

Reaper — механизм "смерти от старости", который:
- Убивает старых/неэффективных организмов
- Освобождает их память через MemoryManager
- Поддерживает круговорот поколений
- Предотвращает стагнацию эволюции

Без Reaper'а память заполняется, организмы перезаписывают друг друга, и эволюция останавливается.

### 7.2. Алгоритм (Age-Based)

Организмы хранятся в очереди, отсортированной по возрасту:

```
ReaperQueue: [Org#0 age=5000] → [Org#3 age=4500] → [Org#7 age=4200] → ...
              ↑ старейший                                    младший ↑
```

**Операции:**

| Метод | Описание |
|-------|----------|
| `register(organism)` | Добавить организм в очередь (при SPAWN) |
| `unregister(organism)` | Удалить из очереди (при смерти от ошибок) |
| `reap()` | Убить одного старейшего, освободить память |
| `reapUntilFree(size)` | Убивать пока не освободится достаточно места |

**Алгоритм reap():**
```
1. Взять старейший организм из очереди
2. Пометить organism.alive = false
3. Вызвать memoryManager.free(org.addr, org.size)
4. Удалить из очереди
5. Увеличить счётчик reapCount
```

### 7.3. Триггеры

| Триггер | Когда срабатывает |
|---------|-------------------|
| **По памяти** | `allocate()` вернул -1 |
| **По популяции** | `organisms.size() >= MAX_POPULATION` |
| **Периодический** | Каждые N циклов (опционально) |

**Основной триггер — нехватка памяти:**
```java
int addr = memoryManager.allocate(size);
if (addr == -1) {
    // Нет места — вызвать Reaper
    reaper.reapUntilFree(size);
    addr = memoryManager.allocate(size);
}
```

### 7.4. Интеграция

```
┌─────────────────────────────────────────────────────────────┐
│                        Scheduler                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   SPAWN ──► Reaper.register(child)                          │
│                                                             │
│   ALLOCATE fails ──► Reaper.reapUntilFree(size)             │
│                          │                                  │
│                          ▼                                  │
│                   MemoryManager.free()                      │
│                          │                                  │
│                          ▼                                  │
│                   Retry ALLOCATE                            │
│                                                             │
│   Death by errors ──► Reaper.unregister(org)                │
│                          │                                  │
│                          ▼                                  │
│                   MemoryManager.free()                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.5. Метрики

| Метрика | Описание |
|---------|----------|
| `reapCount` | Всего убито Reaper'ом |
| `averageAgeAtDeath` | Средний возраст при смерти |
| `oldestAlive` | Возраст старейшего живого |
| `youngestReaped` | Минимальный возраст убитого |

### 7.6. Принцип справедливости

**Почему Age-Based, а не Random:**
- Предсказуемость — легче отлаживать
- Даёт шанс молодым — только что родившиеся не умрут сразу
- Эволюционное давление — кто быстрее размножается, тот выживает
- Как в оригинальной Tierra

**Альтернативы (для будущих экспериментов):**
- **Fitness-based**: убивать тех, кто медленно размножается
- **Error-based**: убивать тех, у кого много ошибок
- **Random**: случайный выбор (хаотичнее, но интереснее?)

---

## 8. Трекинг мутаций

### 8.1. Назначение

MutationTracker записывает все мутации, произошедшие при COPY, чтобы потом можно было:
- Увидеть, какие мутации "выжили" (попали в живых организмов)
- Проанализировать, какие инструкции чаще мутируют
- Понять, какие мутации нейтральны, а какие летальны

### 8.2. Структура

**MutationRecord:**
```java
record MutationRecord(
    long cycle,           // Когда произошла
    int sourceAddr,       // Откуда копировали
    int destAddr,         // Куда записали
    int originalValue,    // Было
    int mutatedValue      // Стало
)
```

**MutationTracker:**
- `record(cycle, src, dst, oldVal, newVal)` — записать мутацию
- `getMutationsInRange(start, end)` — мутации в диапазоне адресов
- `getSurvivedMutations(organisms)` — мутации в живых организмах

### 8.3. Интеграция

```
VirtualCPU.executeCopy():
    if (mutated) {
        tracker.record(cycle, srcAddr, dstAddr, original, mutated);
    }

AdamDemo.printFinalReport():
    List<MutationRecord> survived = tracker.getSurvivedMutations(aliveOrganisms);
    for (mutation : survived) {
        print(disassemble(original) + " → " + disassemble(mutated));
    }
```

---

## 9. Наблюдаемые феномены

### 9.1. Экологическая катастрофа (без Reaper'а)

```
Cycle 500:   100 организмов, память заполнена
Cycle 3000:  Массовое вымирание (перезапись памяти)
Cycle 4000:  41 выживший, эволюция остановилась
Cycle 50000: Стагнация — нет новых spawn'ов
```

**Причина:** Без освобождения памяти организмы перезаписывают друг друга, код повреждается, все умирают.

**Решение:** Reaper освобождает память, создавая устойчивую экосистему.

### 9.2. Самоуничтожение Adam'а

Adam (addr=0) был перезаписан своими потомками:
```
Было: MOVI R4, 13 | MOVI R5, 5 | ALLOCATE...
Стало: MOV R1, R3 | MOV R2, R4 | COPY...
```

Потомки копировали инструкции 3-7 своего генома в область 0-4.

### 9.3. Выжившие линии

Организмы, успевшие "убежать" в безопасные адреса (100-600, 800-1100), выжили и продолжили существовать в повреждённом виде.

### 9.4. Silent Mutations (тихие мутации)

**Феномен:** Мутации в неиспользуемых битах инструкций не влияют на выполнение, но наследуются.

```
MOV R1, R3:  0x012C0000  ← биты 0-19 не используются
             ↓ мутация в бите 14
MOV R1, R3:  0x012C4000  ← выглядит так же, работает так же
```

**Аналог в биологии:** Синонимичные мутации в ДНК, которые не меняют аминокислоту.

### 9.5. Cryptic Variation Bomb (бомба скрытой вариации)

**Феномен:** Накопленный "мусор" в неиспользуемых битах внезапно становится значащим при мутации opcode.

```
Поколение 1:   MOV R1, R3     0x012C0000
                                    ↓ silent mutations накапливаются
Поколение 12:  MOV R1, R3     0x012CFFFF  ← 20 бит "мусора"
                                    ↓ мутация opcode (0x01→0x02)
Поколение 13:  MOVI R1, 1048575  0x022CFFFF  ← BOOM!
```

**Последствия:**
- MOV → MOVI: 20 бит мусора становятся immediate-константой (до 2M!)
- Может загрузить случайный адрес в регистр
- Возможен "эволюционный скачок" — резкое изменение поведения

**Аналог в биологии:** Cryptic genetic variation — скрытая вариация в интронах, которая становится значащей при мутации сплайсинга.

### 9.6. Суперпредки

При работающем Reaper'е иногда один организм становится предком большинства живых:
```
✓ #960: parent=668
✓ #961: parent=668
✓ #962: parent=668
...
```

**Причины:**
- Удачное расположение в памяти (не перезаписывается)
- Возможно, более эффективный геном (быстрее размножается)
- Статистический эффект (founder effect)

---

## 10. Метрики и статистика

### Текущие метрики

| Метрика | Описание |
|---------|----------|
| `totalSpawns` | Всего успешных SPAWN |
| `failedAllocations` | Неудачных ALLOCATE |
| `aliveCount` | Живых организмов |
| `memoryUsed` | Занято ячеек памяти |

### Планируемые метрики

| Метрика | Описание |
|---------|----------|
| `generations` | Глубина родословной |
| `averageAge` | Средний возраст при смерти |
| `replicationRate` | Spawn'ов на организм |
| `diversityIndex` | Уникальных геномов |

---

## 11. Запуск и тестирование

### Запуск демо

```bash
mvn exec:java -Dexec.mainClass="io.github.manjago.proteus.demo.AdamDemo"
```

### Запуск тестов

```bash
mvn test
```

### Структура тестов

```
src/test/java/
└── io/github/manjago/proteus/core/
    ├── OpCodeTest.java        — кодирование инструкций
    ├── VirtualCPUTest.java    — исполнение инструкций
    ├── DisassemblerTest.java  — дизассемблирование
    ├── GenomeBuilderTest.java — построение геномов
    └── AdamTest.java          — репликация Adam'а
```

---

## 12. Roadmap

### ✅ Выполнено (Stage 1-2)

- [x] ISA v1.1 (16 инструкций + MOVI)
- [x] VirtualCPU с мутациями
- [x] Adam (13 инструкций)
- [x] Базовые тесты
- [x] MemoryManager (Free List + First Fit)
- [x] Reaper (Age-Based)
- [x] Organism (отдельный класс)
- [x] Интеграция в AdamDemo — полный цикл жизни с Reaper'ом
- [x] **MutationTracker** — отслеживание и анализ выживших мутаций

### 📋 Планы (Stage 3)

- [ ] **Дефрагментация памяти** — сдвиг организмов для объединения дыр
  - Сложность: нужно обновлять IP у всех организмов после сдвига
  - Триггер: когда fragmentation > threshold и allocate не может найти блок
  - Алгоритм: компактификация — сдвигаем живых к началу soup'а
- [ ] Genealogy tracking (родословные)
- [ ] Diversity metrics (уникальные геномы, расстояние Хэмминга)

### 📋 Планы (Stage 4+)

- [ ] Web UI для визуализации
- [ ] Параллельное исполнение (многопоточность)
- [ ] Сохранение/загрузка состояния
- [ ] Energy-based scheduling (вместо round-robin)

---

## Ссылки

- [Tierra (Wikipedia)](https://en.wikipedia.org/wiki/Tierra_(computer_simulation))
- [Avida](https://en.wikipedia.org/wiki/Avida) — развитие идей Tierra
- [ISA_SPEC.md](ISA_SPEC.md) — полная спецификация инструкций
