# Спецификация Набора Инструкций (ISA) v1.2

> **v1.2 — Position-Independent Code (PIC)**
> Основное изменение: переход на относительную адресацию для поддержки дефрагментации памяти.

Этот документ описывает архитектуру виртуального процессора и набор инструкций, используемых организмами в симуляции.

## 1. Архитектура CPU

*   **Регистры:** 8 регистров общего назначения (`R0` - `R7`). Каждый регистр — 32-битное целое число (`int`).
*   **Указатель Инструкции (`IP`):** Относительное смещение следующей инструкции от `startAddr` организма.
*   **Размер Инструкции:** Все инструкции кодируются одним 32-битным целым числом (`int`).
*   **startAddr:** Абсолютный адрес начала генома организма в памяти (хранится в `Organism`).

### Вычисление реального адреса

```
Реальный IP = startAddr + IP(относительный)
```

При выполнении: `IP++` (после каждой инструкции), но это относительный IP.

### Режимы адресации

| Режим | Формула | Используется в |
|-------|---------|----------------|
| **IP-relative** | `IP = IP + offset` | JMP, JMPZ, JMPN |
| **startAddr-relative** | `addr = startAddr + R` | LOAD, STORE |
| **Absolute** | `addr = R` | COPY, ALLOCATE, SPAWN |

## 2. Кодирование Инструкции

### Стандартный формат (большинство инструкций)

| Биты 31-24 (8) | 23-21 (3) | 20-18 (3) | 17-15 (3) | 14-12 (3) | 11-0 (12) |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **OpCode** | **Reg 1** | **Reg 2** | **Reg 3** | **Reg 4** | **Резерв** |

### Формат MOVI (immediate)

| Биты 31-24 (8) | 23-21 (3) | 20-0 (21) |
| :---: | :---: | :---: |
| **OpCode** | **R_dst** | **Immediate (unsigned)** |

### Формат JMP/JMPZ/JMPN (relative offset) — v1.2

| Биты 31-24 (8) | 23-21 (3) | 20-18 (3) | 17-0 (18) |
| :---: | :---: | :---: | :---: |
| **OpCode** | **R_cond1** | **R_cond2** | **offset (signed)** |

*   **offset:** 18-битное знаковое смещение (-131,072 до +131,071).
*   Интерпретируется как `int` с расширением знака.

## 3. Таблица Инструкций

---
### Категория: Базовые

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x00` | `NOP` | - | No Operation. |
| `0x01` | `MOV` | `R_dst, R_src` | `R_dst = R_src` |
| `0x02` | `MOVI` | `R_dst, imm21` | `R_dst = imm21` (константа 0—2,097,151) |
| `0x03` | `GETADDR` | `R_dst` | **NEW v1.2:** `R_dst = startAddr` — получить свой абсолютный адрес |

---
### Категория: Арифметика

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x10` | `ADD` | `R_a, R_b` | `R_a = R_a + R_b` |
| `0x11` | `SUB` | `R_a, R_b` | `R_a = R_a - R_b` |
| `0x12` | `INC` | `R_a` | `R_a = R_a + 1` |
| `0x13` | `DEC` | `R_a` | `R_a = R_a - 1` |

---
### Категория: Работа с памятью

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x20` | `LOAD` | `R_dst, [R_off]` | `R_dst = soup[startAddr + R_off]` ⚠️ **v1.2: relative** |
| `0x21` | `STORE` | `[R_off], R_src` | `soup[startAddr + R_off] = R_src` ⚠️ **v1.2: relative** |

**Организм может читать/писать только в пределах своего региона памяти!**

---
### Категория: Управление потоком

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x30` | `JMP` | `offset` | `IP = IP + offset` ⚠️ **v1.2: relative** |
| `0x31` | `JMPZ` | `R_cond, offset` | `if (R_cond == 0) IP = IP + offset` ⚠️ **v1.2: relative** |
| `0x32` | `JMPN` | `R_a, R_b, offset` | `if (R_a < R_b) IP = IP + offset` ⚠️ **v1.2: relative** |

**Смещение `offset`** — знаковое 18-битное число. Примеры:
- `JMP -5` — прыгнуть на 5 инструкций назад
- `JMP 3` — прыгнуть на 3 инструкции вперёд
- `JMP 0` — бесконечный цикл (прыгнуть на себя)

---
### Категория: Системные вызовы

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x40` | `COPY` | `[R_src], [R_dst]` | `soup[R_dst] = soup[R_src]` — **абсолютные адреса!** Подвержена мутациям. |
| `0x41` | `ALLOCATE` | `R_size, R_addr` | `R_addr = allocate(R_size)` — возвращает **абсолютный** адрес (или -1) |
| `0x42` | `SPAWN` | `R_addr, R_size` | Создать организм по **абсолютному** адресу |

**Почему COPY абсолютная:** Организм должен писать в child, который находится по другому абсолютному адресу.

---
### Категория: Продвинутые

#### SEARCH — Поиск шаблона в памяти

| OpCode | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x50` | `SEARCH` | `Rs, Rt, Rl, Rf` | Поиск шаблона в памяти (относительная адресация) |

**Синтаксис:** `SEARCH Rs, Rt, Rl, Rf`

**Параметры:**
- `Rs` — offset начала поиска (относительно startAddr)
- `Rt` — offset шаблона в памяти организма (относительно startAddr)
- `Rl` — длина шаблона (количество ячеек)
- `Rf` — результат: **абсолютный** адрес найденного совпадения, или -1 если не найдено

**Алгоритм:**
1. Шаблон берётся из памяти организма: `soup[startAddr + Rt]` ... `soup[startAddr + Rt + Rl - 1]`
2. Поиск начинается с `startAddr + Rs` и идёт вперёд по всей памяти (с wrap-around)
3. При совпадении в `Rf` записывается **абсолютный** адрес первого байта совпадения
4. Если совпадение не найдено, `Rf = -1`

**Важно:**
- Шаблон хранится **внутри генома организма** — это его собственные инструкции
- Поиск охватывает **весь soup**, включая память других организмов
- Результат — **абсолютный** адрес, пригодный для COPY

---

#### Пример 1: Поиск и атака Adam'а

Паразит хочет найти сигнатуру Adam'а (`MOVI R4, 14`) и перезаписать её NOP'ом:

```asm
; Паразит хранит шаблон для поиска в своём теле
; (эта инструкция будет шаблоном, но сам паразит через неё не проходит!)

start:
    GETADDR R7          ; R7 = мой адрес
    MOVI R4, 18         ; R4 = мой размер (18 инструкций)
    
    ; ... код репликации ...
    
    JMP attack          ; Перепрыгиваем шаблон!

template:
    MOVI R4, 14         ; <-- ЭТО ШАБЛОН для поиска (не выполняется!)

attack:
    ; Настройка параметров SEARCH
    MOVI R0, 0          ; Rs = начало поиска (offset 0 = мой startAddr)
    MOVI R1, 11         ; Rt = offset шаблона (template находится на позиции 11)
    MOVI R2, 1          ; Rl = длина шаблона (1 инструкция)
    
    SEARCH R0, R1, R2, R3   ; R3 = абсолютный адрес найденного, или -1
    
    ; Если нашли (R3 != -1), перезаписываем NOP'ом
    MOVI R5, 0          ; R5 = инструкция NOP (0x00000000)
    STORE [R3], R5      ; ОШИБКА! STORE использует relative адресацию!
    
    ; Правильный вариант: используем COPY
    ; Нужно где-то хранить NOP и копировать его
```

**Проблема:** STORE использует относительную адресацию, но SEARCH возвращает абсолютный адрес. Для записи по абсолютному адресу нужно использовать COPY.

---

#### Пример 2: Правильный паразит с COPY

```asm
start:
    GETADDR R7
    MOVI R4, 20
    
    ; ... код репликации (ALLOCATE, COPY loop, SPAWN) ...
    
    JMP attack

; === Данные (не выполняются!) ===
template:
    MOVI R4, 14         ; Шаблон для поиска

weapon:
    NOP                 ; Чем будем перезаписывать

; === Код атаки ===
attack:
    ; Вычисляем абсолютные адреса наших данных
    GETADDR R7
    
    ; Поиск шаблона
    MOVI R0, 0          ; Rs = начать с offset 0
    MOVI R1, 12         ; Rt = offset template (позиция в нашем коде)
    MOVI R2, 1          ; Rl = 1 инструкция
    SEARCH R0, R1, R2, R3   ; R3 = найденный адрес
    
    ; Проверка: нашли ли что-то?
    ; (JMPN R3, R7, skip — если R3 < R7, то это может быть -1)
    
    ; Атака: копируем weapon (NOP) на найденный адрес
    MOVI R1, 13         ; offset weapon в нашем коде
    ADD R5, R7, R1      ; R5 = абсолютный адрес weapon
    COPY R5, R3         ; soup[R3] = soup[R5] (копируем NOP)
    
    JMP start
```

---

#### Защита от паразитов

Паразит ищет точную сигнатуру `MOVI R4, 14`. Но инструкция MOVI имеет 12 резервных бит!

```
MOVI R4, 14:
  Стандартно: 0x0280000E (биты 11-0 = 0)
  С "солью":  0x0280FFFE (биты 11-0 = 0xFFF)
```

Обе инструкции выполняются идентично (`R4 = 14`), но имеют разный hex-код. Паразит с фиксированным шаблоном не найдёт "защищённую" версию!

**В ассемблере:** можно использовать `.word` для указания точного hex-значения:
```asm
.word 0x0280FFFE    ; MOVI R4, 14 с "солью" для защиты от паразитов
```

---

#### Ограничения SEARCH

1. **Не находит себя:** Алгоритм пропускает диапазон `[startAddr, startAddr + size)`
2. **O(n) сложность:** Сканирует весь soup — дорогая операция
3. **Один результат:** Возвращает первое найденное совпадение
4. **Wrap-around:** Поиск wrap-around по памяти (после конца soup идёт начало)

---

## 4. Adam v3 (Position-Independent)

```asm
; === Adam v3 (ISA v1.2, PIC) ===
; Размер: 12 инструкций
; Работает с любого адреса без модификации

; --- Инициализация ---
0: MOVI R0, 0       ; R0 = offset (счётчик копирования)
1: MOVI R4, 12      ; R4 = genome_size (размер этого кода)
2: GETADDR R7       ; R7 = мой абсолютный startAddr

; --- Выделение памяти ---
3: ALLOCATE R4, R3  ; R3 = адрес child'а (абсолютный)

; --- Цикл копирования (начало: IP=4) ---
4: ADD R5, R7, R0   ; R5 = myStart + offset (абс. адрес источника)
5: ADD R6, R3, R0   ; R6 = childStart + offset (абс. адрес назначения)
6: COPY [R5], [R6]  ; soup[R6] = soup[R5] (с возможной мутацией!)
7: INC R0           ; offset++
8: JMPN R0, R4, -5  ; if (R0 < R4) goto IP-5 (т.е. инструкция 4)

; --- Размножение ---
9: SPAWN R3, R4     ; Создать child'а

; --- Сброс и повтор ---
10: MOVI R0, 0      ; Сбросить offset для следующего цикла
11: JMP -9          ; goto IP-9 (т.е. инструкция 3: ALLOCATE)
```

### Трассировка выполнения (первый цикл)

```
IP=0: MOVI R0, 0      → R0=0
IP=1: MOVI R4, 12     → R4=12
IP=2: GETADDR R7      → R7=startAddr (например, 0)
IP=3: ALLOCATE R4, R3 → R3=13 (child по адресу 13)
IP=4: ADD R5, R7, R0  → R5=0+0=0
IP=5: ADD R6, R3, R0  → R6=13+0=13
IP=6: COPY [R5], [R6] → soup[13]=soup[0] (копируем инструкцию 0)
IP=7: INC R0          → R0=1
IP=8: JMPN R0, R4, -5 → 1<12? да → IP=8+(-5)+1=4
... (цикл продолжается до R0=12)
IP=8: JMPN R0, R4, -5 → 12<12? нет → IP=9
IP=9: SPAWN R3, R4    → создан child [13..24]
IP=10: MOVI R0, 0     → R0=0
IP=11: JMP -9         → IP=11+(-9)+1=3
IP=3: ALLOCATE...     → новый цикл размножения
```

---

## 5. Почему PIC (Position-Independent Code)?

### Проблема v1.1

```asm
; Adam v2 содержал:
JMP 0     ; Абсолютный адрес!
JMPN R2, 5  ; Абсолютный адрес!
```

Если Adam скопирован на адрес 100, его `JMP 0` ведёт на адрес 0, а не на начало его кода!

### Решение v1.2

```asm
; Adam v3:
JMP -9    ; Относительный: IP = IP - 9
```

Независимо от startAddr, `JMP -9` ведёт на 9 инструкций назад — туда, куда нужно.

### Преимущества

| Аспект | v1.1 (абсолютная) | v1.2 (относительная) |
|--------|-------------------|----------------------|
| Корректность | ❌ Баг при копировании | ✅ Работает везде |
| Дефрагментация | ❌ Нужно патчить код | ✅ Просто переместить |
| Сложность CPU | ✅ Простой | ✅ Чуть сложнее |

---

## 6. Дефрагментация (тривиальная с PIC)

```java
void defragment(Organism org, int newAddr) {
    int oldAddr = org.getStartAddr();
    int size = org.getSize();
    
    // 1. Копируем геном на новое место
    for (int i = 0; i < size; i++) {
        soup.set(newAddr + i, soup.get(oldAddr + i));
        soup.set(oldAddr + i, 0); // Очищаем старое место
    }
    
    // 2. Обновляем метаданные
    org.setStartAddr(newAddr);
    
    // IP не меняется — он относительный!
    // Код не патчим — он position-independent!
}
```

---

## 7. История версий

| Версия | Изменения |
|--------|-----------|
| v1.0 | Базовая ISA (32 инструкции Adam) |
| v1.1 | Добавлен MOVI, Adam сжат до 13 инструкций |
| **v1.2** | **PIC: JMP/LOAD/STORE относительные, добавлен GETADDR, Adam v3 (12 инструкций)** |

---

## 8. Кодирование инструкций Adam v3

| # | Asm | Hex (примерно) |
|---|-----|----------------|
| 0 | `MOVI R0, 0` | `0x02000000` |
| 1 | `MOVI R4, 12` | `0x0280000C` |
| 2 | `GETADDR R7` | `0x03E00000` |
| 3 | `ALLOCATE R4, R3` | `0x41860000` |
| 4 | `ADD R5, R7, R0` | `0x10AE0000` |
| 5 | `ADD R6, R3, R0` | `0x10C60000` |
| 6 | `COPY [R5], [R6]` | `0x40AC0000` |
| 7 | `INC R0` | `0x12000000` |
| 8 | `JMPN R0, R4, -5` | `0x32083FFB` |
| 9 | `SPAWN R3, R4` | `0x42680000` |
| 10 | `MOVI R0, 0` | `0x02000000` |
| 11 | `JMP -9` | `0x30003FF7` |
