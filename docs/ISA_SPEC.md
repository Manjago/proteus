# Спецификация Набора Инструкций (ISA) v1.1

Этот документ описывает архитектуру виртуального процессора и набор инструкций, используемых организмами в симуляции.

## 1. Архитектура CPU

*   **Регистры:** 8 регистров общего назначения (`R0` - `R7`). Каждый регистр — 32-битное целое число (`int`).
*   **Указатель Инструкции (`IP`):** Специальный регистр, хранящий адрес *следующей* для выполнения инструкции в основной памяти ("супе").
*   **Размер Инструкции:** Все инструкции кодируются одним 32-битным целым числом (`int`).
*   **Адресация памяти:** Большинство инструкций, работающих с памятью, используют **регистрово-косвенную адресацию**. Это означает, что адрес ячейки памяти берется из значения, хранящегося в указанном регистре.

## 2. Кодирование Инструкции

### Стандартный формат (большинство инструкций)

| Биты 31-24 (8) | 23-21 (3) | 20-18 (3) | 17-15 (3) | 14-12 (3) | 11-0 (12) |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **OpCode** | **Reg 1** | **Reg 2** | **Reg 3** | **Reg 4** | **Резерв** |

*   **OpCode:** Код операции (например, `0x01` для `MOV`).
*   **Reg 1-4:** Номера регистров-операндов (от 0 до 7). В зависимости от инструкции, используются не все поля.

### Формат с непосредственным значением (MOVI)

| Биты 31-24 (8) | 23-21 (3) | 20-0 (21) |
| :---: | :---: | :---: |
| **OpCode** | **R_dst** | **Immediate** |

*   **Immediate:** 21-битное беззнаковое значение (0 — 2,097,151).

## 3. Таблица Инструкций

---
### Категория: Базовые

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x00` | `NOP` | - | **No Operation.** Не выполняет никаких действий. Затрачивает 1 цикл CPU. |
| `0x01` | `MOV` | `R_dst, R_src` | **Move.** `R_dst = R_src`. Копирует значение из `R_src` в `R_dst`. |
| `0x02` | `MOVI` | `R_dst, imm21` | **Move Immediate.** `R_dst = imm21`. Загружает 21-битную константу (0—2,097,151) непосредственно в регистр. |

---
### Категория: Арифметика

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x10` | `ADD` | `R_a, R_b` | **Add.** `R_a = R_a + R_b`. Складывает значения регистров. Результат в `R_a`. |
| `0x11` | `SUB` | `R_a, R_b` | **Subtract.** `R_a = R_a - R_b`. Вычитает значение `R_b` из `R_a`. Результат в `R_a`. |
| `0x12` | `INC` | `R_a` | **Increment.** `R_a = R_a + 1`. Увеличивает значение регистра на 1. |
| `0x13` | `DEC` | `R_a` | **Decrement.** `R_a = R_a - 1`. Уменьшает значение регистра на 1. |

---
### Категория: Работа с памятью

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x20` | `LOAD` | `R_dst, [R_addr]` | **Load.** `R_dst = memory[R_addr]`. Загружает значение из ячейки памяти с адресом, хранящимся в `R_addr`, в регистр `R_dst`. |
| `0x21` | `STORE` | `[R_addr], R_src` | **Store.** `memory[R_addr] = R_src`. Сохраняет значение из регистра `R_src` в ячейку памяти с адресом, хранящимся в `R_addr`. |

---
### Категория: Управление потоком

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x30` | `JMP` | `[R_addr]` | **Jump.** `IP = value(R_addr)`. Безусловный переход. Устанавливает `IP` равным значению в `R_addr`. |
| `0x31` | `JMPZ` | `R_cond, [R_addr]` | **Jump if Zero.** `if (value(R_cond) == 0) IP = value(R_addr)`. Переход, если значение в `R_cond` равно нулю. |
| `0x32` | `JMPN` | `R_cond, [R_addr]` | **Jump if Not Zero.** `if (value(R_cond) != 0) IP = value(R_addr)`. Переход, если значение в `R_cond` не равно нулю. |

---
### Категория: Системные вызовы (Syscalls)

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x40` | `COPY` | `[R_src], [R_dst]` | **Copy.** Копирует одно 32-битное слово из `memory[R_src]` в `memory[R_dst]`. **Внимание:** Эта операция подвержена случайным мутациям с небольшой вероятностью. |
| `0x41` | `ALLOCATE` | `R_size, R_addr` | **Allocate Memory.** Запрашивает у планировщика непрерывный блок памяти. Размер блока берется из `R_size`. В случае успеха, начальный адрес блока записывается в `R_addr`. В случае неудачи (нет свободной памяти), в `R_addr` записывается `-1`. |
| `0x42` | `SPAWN` | `R_addr, R_size` | **Spawn new Organism.** Сообщает планировщику, что по адресу из `R_addr` находится геном нового организма размером из `R_size`. Планировщик добавляет новый организм в очередь на исполнение. |

---
### Категория: Продвинутые инструкции

| OpCode (Hex) | Мnemonic | Операнды | Описание |
| :--- | :--- | :--- | :--- |
| `0x50` | `SEARCH` | `Rs, Rt, Rl, Rf` | **Search Template.** Ищет в памяти последовательность инструкций (шаблон). Поиск начинается с адреса в `Rs`. Адрес самого шаблона находится в `Rt`, а его длина — в `Rl`. В случае успеха, адрес найденного вхождения записывается в `Rf`. В случае неудачи, в `Rf` записывается `-1`. |

---

## 4. Примеры

### Загрузка константы (старый способ vs MOVI)

**Старый способ (загрузка 32):**
```asm
INC  R4          ; R4 = 1
ADD  R4, R4      ; R4 = 2
ADD  R4, R4      ; R4 = 4
ADD  R4, R4      ; R4 = 8
ADD  R4, R4      ; R4 = 16
ADD  R4, R4      ; R4 = 32
; 6 инструкций!
```

**С MOVI:**
```asm
MOVI R4, 32      ; R4 = 32
; 1 инструкция!
```

### Простой самокопирующийся организм (Adam v2)

```asm
; Инициализация констант
MOVI R4, 15      ; R4 = SIZE (размер этого генома)
MOVI R5, 6       ; R5 = COPY_LOOP (адрес цикла копирования)

; Выделение памяти для потомка
ALLOCATE R4, R3  ; R3 = адрес нового блока (или -1)

; Подготовка к копированию
MOV  R1, R3      ; R1 = destination pointer
MOV  R2, R4      ; R2 = counter

; Цикл копирования (адрес 6)
COPY  [R0], [R1] ; memory[R1] = memory[R0] (с возможной мутацией!)
INC   R0         ; source++
INC   R1         ; dest++
DEC   R2         ; counter--
JMPN  R2, R5     ; if counter != 0, goto COPY_LOOP

; Создание потомка
SPAWN R3, R4     ; Зарегистрировать нового организма

; Сброс для следующего цикла
SUB  R0, R0      ; R0 = 0
JMP  R6          ; R6 = 0, goto start

; Размер: 15 инструкций (было 32!)
```
